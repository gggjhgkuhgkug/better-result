# Improve Context7 Score for better-result

## Problem

Two questions scored below 90:

| Question | Score | Gap |
|----------|-------|-----|
| Q1: Retry with error-type filtering | 81 | No `shouldRetry` predicate in API |
| Q2: mapError on Result.gen() output | 77 | No example showing combined usage |

---

## Plan

### 1. Add `shouldRetry` predicate to RetryConfig

**File:** `src/result.ts`

**Type change (line 441-447):**
```ts
type RetryConfig<E> = {
  retry?: {
    times: number;
    delayMs: number;
    backoff: "linear" | "constant" | "exponential";
    shouldRetry?: (error: E) => boolean; // NEW
  };
};
```

**Implementation change (line 500):**
```ts
// Before
for (let attempt = 0; attempt < retry.times && result.status === "error"; attempt++) {

// After
const shouldRetry = retry.shouldRetry ?? (() => true);
for (
  let attempt = 0;
  attempt < retry.times && result.status === "error" && shouldRetry(result.error);
  attempt++
) {
```

**JSDoc update (line 820-830):**
```ts
/**
 * Executes async function, wraps result/error in Result with retry support.
 *
 * @example
 * // Basic retry
 * await Result.tryPromise(() => fetch(url), {
 *   retry: { times: 3, delayMs: 100, backoff: "exponential" }
 * })
 *
 * @example
 * // Retry only for specific error types
 * await Result.tryPromise({
 *   try: () => fetch(url),
 *   catch: e => e instanceof NetworkError ? new RetryableError(e) : new FatalError(e)
 * }, {
 *   retry: {
 *     times: 3,
 *     delayMs: 100,
 *     backoff: "exponential",
 *     shouldRetry: e => e._tag === "RetryableError"
 *   }
 * })
 */
```

### 2. Add test for `shouldRetry`

**File:** `src/result.test.ts`

Add test case in the `tryPromise` describe block (~line 235):
```ts
it("respects shouldRetry predicate", async () => {
  let attempts = 0;
  const result = await Result.tryPromise({
    try: () => {
      attempts++;
      throw new Error(attempts === 1 ? "retryable" : "fatal");
    },
    catch: e => ({ retryable: e.message === "retryable", msg: e.message })
  }, {
    retry: {
      times: 3,
      delayMs: 1,
      backoff: "constant",
      shouldRetry: e => e.retryable
    }
  });
  
  expect(attempts).toBe(2); // Tried once, retried once, stopped on non-retryable
  expect(result.isErr()).toBe(true);
});
```

### 3. Update README.md

**Add under "Retry Support" section (after line 165):**

```md
### Conditional Retry

Retry only for specific error types using `shouldRetry`:

```ts
class NetworkError extends TaggedError("NetworkError")<{ message: string }>() {}
class ValidationError extends TaggedError("ValidationError")<{ message: string }>() {}

const result = await Result.tryPromise({
  try: () => fetchData(url),
  catch: (e) => isNetworkError(e) ? new NetworkError({ message: e.message }) : new ValidationError({ message: String(e) })
}, {
  retry: {
    times: 3,
    delayMs: 100,
    backoff: "exponential",
    shouldRetry: (e) => e._tag === "NetworkError" // Only retry network errors
  }
});
```
```

### 4. Add mapError + Result.gen() example

**File:** `README.md`

**Add new section after "Generator Composition" (after line 153):**

```md
### Normalizing Error Types

Use `mapError` on the output of `Result.gen()` to unify multiple error types:

```ts
class ParseError extends TaggedError("ParseError")<{ message: string }>() {}
class ValidationError extends TaggedError("ValidationError")<{ message: string }>() {}
class AppError extends TaggedError("AppError")<{ source: string; message: string }>() {}

const result = Result.gen(function* () {
  const parsed = yield* parseInput(input);   // Err: ParseError
  const valid = yield* validate(parsed);     // Err: ValidationError
  return Result.ok(valid);
}).mapError((e): AppError => new AppError({ source: e._tag, message: e.message }));
// Result<Valid, AppError>
```
```

**File:** `src/result.ts`

**Update Result.gen JSDoc (line 897-914):**
```ts
/**
 * Generator-based composition for Result types.
 * Errors from yielded Results form a union; use mapError to normalize.
 *
 * @example
 * const result = Result.gen(function* () {
 *   const a = yield* getA(); // Err: ErrorA
 *   const b = yield* getB(a); // Err: ErrorB
 *   return Result.ok({ a, b });
 * });
 * // Result<{a, b}, ErrorA | ErrorB>
 *
 * @example
 * // Normalize error types with mapError
 * const result = Result.gen(function* () {
 *   const a = yield* getA();
 *   const b = yield* getB(a);
 *   return Result.ok({ a, b });
 * }).mapError(e => new UnifiedError(e._tag, e.message));
 * // Result<{a, b}, UnifiedError>
 */
```

### 5. Update context7.json

**Add rules (line 20, before closing bracket):**

```json
"Use shouldRetry predicate in retry config to conditionally retry based on error type - e.g., { retry: { times: 3, delayMs: 100, backoff: 'exponential', shouldRetry: e => e._tag === 'NetworkError' } }",
"Chain .mapError() on Result.gen() output to normalize multiple error types into a single unified error - transforms ErrorA | ErrorB union into UnifiedError"
```

---

## Files to Modify

| File | Changes |
|------|---------|
| `src/result.ts:441-447` | Add `shouldRetry` to RetryConfig type |
| `src/result.ts:500` | Update retry loop to check shouldRetry |
| `src/result.ts:820-830` | Update tryPromise JSDoc |
| `src/result.ts:897-914` | Update gen JSDoc with mapError example |
| `src/result.test.ts:~235` | Add shouldRetry test |
| `README.md:~165` | Add Conditional Retry section |
| `README.md:~153` | Add Normalizing Error Types section |
| `context7.json:~20` | Add 2 new rules |

---

## Verification

1. `bun run check` - Type-check passes
2. `bun test` - All tests pass (including new shouldRetry test)
3. `bun run lint` - No lint errors
4. Review that new docs/rules directly address the Context7 questions
